Object Oriented Programming:
"An organized method of writing codes."
It involves:
--------------------------------------------------------------------------------------------------------------------
1. Classes                             |   2. Objects                                   |   3. Methods
Class is like a blueprint for the      |   Objects are the entities in the world.       |   These are the functions
entities.                              |                                                |   written in the classes
                                       |                                                |   for the properties.
---------------------------------------------------------------------------------------------------------------------
For example:
Toyota Car company have created a blueprint for the other cars building to follow that particular blueprint.
So, the blueprint is the class and the other cars which have to follow that blueprint are called the objects.

Access Modifiers:
--------------------------------------------------------------------------------------------------------------------
1. Private                             |   2. Public                                   |   3. Protected
Data & member functions are            |   Data and methods are accessible             |                           
accessible only inside the class.      |   to everyone.                                |    Data & methods are 
                                       |   to everyone.                                |    accessible only inside 
                                       |                                               |    class & its derived 
                                       |                                               |     class.
---------------------------------------------------------------------------------------------------------------------

Setters & Getters:
Setters and getters are very important as they help us to access the private members/member functions easily out of
the class aswell.



Constructors:
It is a special method invoked automatically at the time of object creation. It is used for the initialization.
Properties of Constructor:
Same name as class.
Do not have the return type.
Only called once at the time of object creation.
Memory allocation happens when constructor is called.
Types of Constructor:
1. Parameterized Constructor.         (Takes the arguments to initialize the properties)
2. Non-Parameterized Constructor.     (No paramters initialize the properties with default values)
3. Copy Constructor.                  (Create a new object as the copy of other object)
Copy Constructor is the special type of constructor that used to copy properties of one object into another.
For example:
Teacher T1;
Teacher(T2)
T1                           exactly same                           T2
name                            copy                                name
age                          as T1 exists                           age
salary                                                              salary
Teacher(Teacher &orgobj){                        Call by reference
    this->name  = orgobj.name;                   this cannot be done with call by value because it will couse infinite recursive calls 
    this->age  = orgobj.age;
}

Shallow Copy                                                            Deep Copy
Shallow copy of an object copies all                                    Deep copy on the other hand, not only 
the member values from one object to                                    copies the member values but also make
another.                                                                copies of any dynamically allocated memory
                                                                        that the member points too.
Let's dive deep:
In shallow copy:
So when we are changing the object property of S2.property then the S1.property gets changed automatically although we did'nt wanted that change. This is happening because of same
memory location they share with each other.
But in deep copy this problem can be solved easily:
Student S1;
Student(S2)
S1                           exactly same                           S2
name                         memory location                        name                        This is all the process being done in the heap.
cgpaptr                      as S1 exists                           cgpaptr                     cgpaptr points the different memory location suppose 555555 for S1
555555                                                              666666                      and 666666 for S2.So they are pointing different memory locations.
So when we are changing the object property of S2.property then the S1.property do not get changed. This is happening because of different 
memory location they have due to the deep copy.


Diving deep to the memory allocation:
Static Memory allocation is done in the stack by default like it is done in the compile time.
    Stack                    
|             |             Suppose                                              
|             |             int x =5;
|  int x =5   |
Dynamic Memory Allocation is carried out in the heap like
new int[5]   now the allocation has been set at the runtime

Constructor Overloading:
Multiple constructor can be made in a single code with differnt types of parameters depending upon the requirements.So, whichever constructor we call, we know
which type of parameters are given and there sequence as well. This all process of multiple constructor calling at the same time is called the constructor 
overloading. It is one of the example of polymorphism.


Pointers in OOP:
this pointer:
this is a special type of pointer in c++ that points to the current object.
this->prop is same as *(this).prop
Example:
Teacher(string name , string address){                      Here Teacher is the constructor and this-> tells the compiler that this is the object member 
    this->name  = name ;                                    while other one is the constructor parameter.
    this->address  = address ;    
}
Now diving deep:
Objects of the class occupies the memory by allocating the different memory allocations to its member/member functions. this pointer directly points the 
memory that involves the member/member functions. 
Suppose                                                                    Same as:
int x = 10;                                                                *(this).property    represents the object.property
int * ptr = x;        * = dereferncing operater
*ptr                  *ptr will print the 10


Destructor:
it is the opposite of the constructor.
Destructot deallocates the static memory. for dynamic memory deallocation we use the delete keyword.
Properties:
Same name as the class, but preceded by a tilde ~
No return type, not even void
No parameters (cannot be overloaded)
New for dynamic memory creation while delete for the dynamic memory deallocation. So, it saves us from the memory leackage as the dynamic memory staays untill we use the 
delete keyword.
In case of inheritance the object of derive class is destroyed first then the object of parent class is destroyed.

Pillars of OOP:
1. Encapsulation.
2. Inheritance.
3. Polymorphism
4. Abstraction.

1. Encapsulation:
It is the process of wrapping up the data members and member functions in a single unit class.
Data Properties    +    Member Functions    = Class
Uses:
Data Hiding (Used to improve the security)
It is the process of making the sensitive member/member function private/protected.


2. Inheritance:
When properties and member functions of the base class are passed on to the derived class. The process is called the Inheritance.
For example:
Class A     -----------------------  Class B
Parent Class                         Child Class
Base Class                           Derived Class
Lets dive deep:
Whenever the object of derived class is created then the constructor of base class is created first then the constructor of derived class is called.

Mode of Inheritance:
-----------------------------------------------------------------------------------------------------------------------
Base Class             |        Private             |        Protected             |          Public
-----------------------------------------------------------------------------------------------------------------------
Private                |        not inherited       |        not inherited         |         not inherited
Protected              |        Private             |        Protected             |         Protected
Public                 |        Private             |        Protected             |         Public

Types of Inheritance:
1. Single Inheritance
One derived class inherits from one base class.
2. Multilevel Inheritance
A class inherits from a class, which itself inherits from another class (chain of inheritance).
3. Multiple Inheritance
A single class inherits from two or more base classes.
4. Hierarchical Inheritance
Multiple classes inherit from the same single base class.
5. Hybrid Inheritance 
A combination of two or more types of inheritance (for example:  multiple + hierarchical).


3. Polymorphism:
it is the ability of objects to take on different forms or behave in different ways depending upon the context in which they are used.
Types of Polymorphism:
1. Compile Time Polymorphism 
for example (Constructor Overloading, Function Overloading & Operater Overloading)
Constructor Overloading: 
Multiple constructors in the same class with different sets of parameters.
It allows object creation in different ways, depending on available data.
Function Overloading: 
Same function name but with different parameters (number or type). It happens at compile time.
Allows us to define multiple versions of a function to handle different data types or scenarios.
Operater Overloading:
Using operators (like +, -, etc.) with user-defined types (objects).
Allows intuitive use of operators with objects.
2. Run-time Polymorphism
for example ( Function Overriding )
Function Overriding:
A child class redefines a function from its base class. Requires a virtual keyword in base class.
It supports dynamic behavior, especially when using base class pointers.
Virtual Funtion:
Virtual Function is a member function  that you expect to be redefined in derived class.
Properties:
Dynamic in nature.
Defined by keyword "virtual" inside the base class and are always declared with the base class and overriden in derived class.

4. Abstraction:
Hiding all the unnecessary details and showing the only required/necessary part.
Abstraction differs from the data hiding as the abstraction shows some part of the data as well.
 
Abstract Classes:
Abstract classes are used to provide the base classes from which the other classses can be derived.
They cannot be instantiated and are meant to be inherited.
Abstract classes are typically used to define a format or interface for the derived classes.



Static Keyword:
Variables declared as static in a function are created & initialized once for the lifetime of the program. (In function)
Static variables in a class are created & initialized once. They are shared by all the objects of the class. (In class)
Let dive deep:
Suppose an example:
void func(){                                          In this case everytime func() is called           
    static int x =0 ;                                 As there is the memory allocation in the stack
    cout << x << endl;                                 |          |
    x++;                                               |          |
}                                                      |  func()  |         everytime func() is created and deleted 
    func();                                            |          |         again and again whenever there is the funcion call.
    func();
    func();
    func();

but if we add the keyword static to the function
    static int x = 0;                                   there is no everytime creation and updation everytime
                                                        so if we add the keyword static there is the creation for only 
                                                        single time.
Now we will be discussing it in the classes as well:
class A{                                          
    public:                                  Here actually the both of the objects are going towards the 
    int x;                                   different memory locations that is why they are giving different values.
};                                           But in case of static the variable x will be same for all the objects. they will
A obj1;                                      be accessing it all. I mean all the objects will be accessing it 
    obj1.x = 10;
    cout << obj1.x << endl;
    A obj2;
    obj2.x = 100;
    cout << obj2.x << endl;


Friend Function

A friend function is a non-member function that can access a class’s private and protected members.
It is declared using the keyword "friend" inside the class.
It helps in operator overloading and external utility functions.
Not a class member, but still has special access.

Friend Class

A friend class can access the private/protected members of another class.
It allows full access to the internals of the target class.
Declared using the "friend class" keyword.


Key Points:
Friendship is not mutual.
Friendship is not inherited.
Use it carefully to avoid breaking encapsulation.









